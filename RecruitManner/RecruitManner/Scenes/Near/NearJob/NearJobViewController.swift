//
//  NearJobViewController.swift
//  RecruitManner
//
//  Created by xiaohui on 16/11/15.
//  Copyright (c) 2016年 Jiang Duan. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit
import CustomViews
import CoreLocation

protocol NearJobViewControllerInput {

    func displaySomething(viewModel: NearJob.ViewModel)
}

protocol NearJobViewControllerOutput {

    func doSomething(request: NearJob.Request)
}


// ============================================================================= //
// MARK: - NearJobViewController Class Definition
// ============================================================================= //
class NearJobViewController: UIViewController, NearJobViewControllerInput {

    var output: NearJobViewControllerOutput!
    var router: NearJobRouter!
    
    @IBOutlet weak var childView1: UIView!
    @IBOutlet weak var childView2: UIView!
    
    @IBOutlet weak var navigationItemView: NavigationItemView!
  
    @IBOutlet weak var tableView: UITableView!
    
    let locationManager = CLLocationManager()
    // MARK: Object lifecycle
  
    override func awakeFromNib() {

        super.awakeFromNib()
        NearJobConfigurator.sharedInstance.configure(viewController: self)
    }
    
    @IBAction func selectCompanyAction(_ sender: Any) {
        
        //self.switchChildViewController(sender)
        childView2.isHidden = !childView2.isHidden
        childView1.isHidden = true
        
    }
    
    @IBAction func selectJobAction(_ sender: UIButton) {
        //self.switchChildViewController(sender)
        childView1.isHidden = !childView1.isHidden
        childView2.isHidden = true

    }
    
    // MARK: View lifecycle
  
    override func viewDidLoad() {

        super.viewDidLoad()
        doSomethingOnLoad()
        self.navigationItemView.delegate = self
        
        let saveCityName = UserDefaults.standard.string(forKey: "KCityName")
        if saveCityName == nil || saveCityName == ""{
            self.loadLocation()
        } else {
            self.navigationItemView.cityTitle = saveCityName
        }

    }
  
    // MARK: Event handling
  
    func doSomethingOnLoad() {
        // NOTE: Ask the Interactor to do some work
    
        let request = NearJob.Request()
        output.doSomething(request: request)
    }
  
    // MARK: Display logic
  
    func displaySomething(viewModel: NearJob.ViewModel) {
        // NOTE: Display the result from the Presenter
    
        // nameTextField.text = viewModel.name
    }

}

extension NearJobViewController:UITableViewDelegate,UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return 5
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "JobNearIdentifier", for: indexPath)
        return cell
    }
}

extension NearJobViewController: NavigationItemViewDelegate {
    func cityButtonAction() {
        let jobCityViewController = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "JobCityViewController")
        self.navigationController?.pushViewController(jobCityViewController, animated: true)
    }
    
    func cancelButtonAction() {
    }
    
    func navigationSearchBarButtonClicked(_ searchBar: UISearchBar) -> Bool {
        return true
    }
    
    func navigationSearchBarTextDidEndEditing(_ searchBar: UISearchBar) {
        print(searchBar.text ?? "test")
        searchBar.resignFirstResponder()
    }

    func navigationsearchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        searchBar.resignFirstResponder()
    }
    
}

extension NearJobViewController:CLLocationManagerDelegate {
    
    func loadLocation() {
        if CLLocationManager.locationServicesEnabled() {
            self.locationManager.delegate = self
            self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
            self.locationManager.requestWhenInUseAuthorization()
            self.locationManager.startUpdatingLocation()
        } else {
            
        }
        
    }
    
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        let currentLocation:CLLocation = locations.last!
        self.lonLatToCity(location: currentLocation)
        manager.stopUpdatingLocation()
    }
    
    func lonLatToCity(location: CLLocation) {
        let geocoder = CLGeocoder()
        geocoder.reverseGeocodeLocation(location){(placemarks, error) -> Void in
            if (error == nil) {
                let array = placemarks! as [CLPlacemark]
                
                if (array.count > 0){
                    
                    let pm = array[0]
                    var subThoroughtare:String = ""
                    var thoroughfare:String = ""
                    var subLocality:String = ""
                    var locality:String = ""
                    
                    if pm.subThoroughfare != nil {subThoroughtare = pm.subThoroughfare!}
                    if pm.thoroughfare != nil {thoroughfare = pm.thoroughfare!}
                    if pm.subLocality != nil {subLocality = pm.subLocality!}
                    if pm.locality != nil {locality = pm.locality!}
                    locality = locality.replacingOccurrences(of: "市", with: "")
                    self.navigationItemView.cityTitle = locality
                    print("\(subThoroughtare) \(thoroughfare) \n \(subLocality) \n \(locality) \n ")
                }else{
                    print("No Placemarks!")
                }
            } else {
                print(error.debugDescription)
            }
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFinishDeferredUpdatesWithError error: Error?) {
        print(error?.localizedDescription ?? "")
    }
}


